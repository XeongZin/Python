# -*- coding: utf-8 -*-
"""DCC_DialTone_Assign_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cOS5kmr_JfOLq2ayiiGd2YYtGrfloxCD
"""

''' Part 1) 다이얼톤 파일 들어보기 '''
from IPython.display import Audio
fin = 'dialtone.wav'
fout = 'output.wav'

Audio(fin, autoplay=True)

''' Part 2) 다이얼톤 파일 읽어오기 '''
from scipy.io import wavfile
import numpy

[fs, data] = wavfile.read(fin)              # fs: 샘플링 레이트, data: 샘플의 배열
n = len(data)                               #  n: 샘플의 수
t = numpy.linspace(0, (n-1)/fs, n)         #  t: 샘플링 레이트와 샘플의 수로 계산한 타임스탬프   
t1_amp = data / 32768                      # t1_amp : 데이터가 16비트의 형태를 가지고 있으니깐 32768

print(['data: ', data])
print(fs)
print(t1_amp)
print(t)

''' Part 3) 시간축에서 신호의 파형을 그래프로 그려보기 '''
import matplotlib.pyplot as plt
from matplotlib.pyplot import figure

figure(figsize=(18, 6), dpi=80)

plt.stem(t, t1_amp, markerfmt=" ", use_line_collection=True)
plt.xlabel("Time (s)");
plt.ylabel("Normalized Amplitude");
plt.title("Dial Tone on Time Domain");
plt.grid('on');
plt.axis([0, (n-1)/fs, min(t1_amp), 1])

''' Part 4) 푸리에 변환을 수행하고 주파수 축에서의 파형을 그래프로 그려보기 '''
f0_amp = numpy.fft.fft(t1_amp, n) / n #computes the fft
freq = numpy.linspace(0, fs, n)
P2 = f0_amp

figure(figsize=(18, 6), dpi=80)
plt.stem(freq, numpy.conj(f0_amp), 'r', markerfmt=" ", use_line_collection=True)
plt.axis([0, fs, 0, max(abs(f0_amp))])
plt.grid('on')

''' Part 5) 유효 데이터에 대한 주파수 축에서의 파형을 그래프로 그려보기 '''
m = int(n/2)

P1 = P2
P1 = P1[0:m+1]
P1[1:m] = 2 * P1[1:m]
f1_amp = P1
f = numpy.linspace(0, fs/2, m+1)

print(len(f))
print(len(f1_amp))
print(f)
figure(figsize=(18, 6), dpi=80)

plt.stem(f, numpy.conj(f1_amp), 'r', markerfmt=" ", use_line_collection=True)
plt.xlabel("Frequency (Hz)");
plt.ylabel("Noised Amplitude");
plt.title("Dial Tone on Frequency Domain");
plt.axis([0, fs/2, 0, max(abs(f1_amp))])
plt.grid('on')

''' Part 6) 검사 주파수 영역 설정하기 '''
LOW_FREQ  = [697, 770, 852, 941];      # 다이얼 톤을 구성하는 하한 주파수 
HIGH_FREQ = [1209, 1336, 1477];        # 다이얼 톤을 구성하는 상한 주파수
BW = 30

lb = [0];
ub = [];
for lf in LOW_FREQ:
    lb = numpy.append(lb, lf + BW/2)
    ub = numpy.append(ub, lf - BW/2)
for uf in HIGH_FREQ:
    lb = numpy.append(lb, uf + BW/2)
    ub = numpy.append(ub, uf - BW/2)
ub = numpy.append(ub, fs/2)
print(lb)
print(ub)

''' Part 7) 노이즈 제거 후 파형 출력하기 '''
f2_amp = f1_amp
for i in range(0, len(lb)):
    idx = (f >= lb[i]) & (f < ub[i])
    f2_amp[idx] = 0
    
figure(figsize=(18, 6), dpi=80)
plt.stem(f, numpy.conj(f2_amp), 'g', markerfmt=" ", use_line_collection=True)
plt.xlabel("Frequency (Hz)");
plt.ylabel("Denoised Amplitude");
plt.title("Noise-Removed Dial Tone on Frequency Domain");
plt.grid('on');
plt.grid('minor');
plt.axis([0, fs/2, 0, max(abs(f2_amp))])

''' Part 8) 푸리에 역변환 수행 후 파형 출력하기 '''
t2_amp = numpy.fft.irfft(f2_amp * n, n);

num_list = [];

noise = (max(t2_amp))*0.6

#4.1 noise 줄이기
for i in range(0,n) :
  if(-noise<t2_amp[i]<noise) :
    t2_amp[i] = t2_amp[i]*0.15
  else :
    num_list.append(i); #소음의 범위에 들어가지 않는 위치을 num_list에 추가

size=len(num_list)
start_point=[]
end_point=[]

#4.2 각 위치들 사이의 거리가 150, 즉 0.01875초동안 소리가 없을 경우 다른 다이얼이라고 간주하고 구간 나누기
start_point.append(num_list[0])

for i in range(1,size-2) :
  if((num_list[i+1]-num_list[i])>150) :
    end_point.append(num_list[i])
    start_point.append(num_list[i+1])

end_point.append(num_list[size-1])

print(start_point)
print(end_point)

figure(figsize=(18, 6), dpi=80)
plt.plot(t, numpy.conj(t2_amp));

plt.xlabel("Time (s)");
plt.ylabel("Normalized Amplitude");
plt.title("Pass-Filtered Dial Tone on Time Domain");
plt.grid('on');
plt.grid('minor');

plt.axis([0, (n-1)/fs, min(t2_amp), max(t2_amp)])

'''푸리에 역변환 한 파형을 시간에 따라 나누기'''
#t2_amp에서 200개 넘게 연속해서 0이 나온다면 다이얼 음이 끝났다고 가정.

total_point=len(start_point)

lb_div=[]
ub_div=[]
numbers=[]

location = []

for lf in LOW_FREQ:
  lb_div = numpy.append(lb_div, lf - BW/2)
  ub_div = numpy.append(ub_div, lf + BW/2)
for uf in HIGH_FREQ:
  lb_div = numpy.append(lb_div, uf - BW/2)
  ub_div = numpy.append(ub_div, uf + BW/2)

for i in range(0,total_point):
  t2_list=[]

  #4.3 구간 별 푸리에 변환
  for j in range(start_point[i], end_point[i]) :
    t2_list.append(t2_amp[j])
  num_array = numpy.array(t2_list)

  f3_amp = numpy.fft.fft(num_array, size) / size
  freq_1 = numpy.linspace(0, fs, size)
  
  #4.3 푸리에 변환 후 필요한 주파수 외 나머지 주파수 삭제
  for k in range(0, 8):
    idx = (freq_1 >= lb[k]) & (freq_1 < ub[k])
    f3_amp[idx] = 0
  '''
  #4.3(result) 푸리에 변환 후 필요한 주파수 외 나머지 주파수 삭제하고 출력
  figure(figsize=(18, 6), dpi=80)
  plt.stem(freq_1, numpy.conj(f3_amp), 'g', markerfmt=" ", use_line_collection=True)
  plt.xlabel("Frequency (Hz)");
  plt.ylabel("Denoised Amplitude");
  plt.title("Noise-Removed Dial Tone on Frequency Domain");
  plt.grid('on');
  plt.grid('minor');
  plt.axis([650, 1500, 0, max(abs(f3_amp))])
  '''

  #4.4
  ave_list=[]
  for k in range(0, 7):
    idk = ((freq_1 >= lb_div[k])&(freq_1 <= ub_div[k]))
    ave_list.append(max(abs(f3_amp[idk])))

  ave=0
  for x in range(0,4) :
    ave = ave + ave_list[x]
  ave=ave/4
  for x in range(0,4) :
    if(ave_list[x]>ave) :
      x1=x
    
  for x in range(4,7) :
    ave = ave + ave_list[x]
  ave=ave/4
  for x in range(4,7) :
    if(ave_list[x]>ave) :
      y1=x-4

  keypad = ([1,2,3,],[4,5,6],[7,8,9],["*",0,"#"])
  location.append('(')
  location.append(x1)
  location.append(',')
  location.append(y1)
  location.append(')')
  numbers.append(keypad[x1][y1])

print(location)
print(numbers)

''' Part 9) 노이즈가 제거된 다이얼톤 파일 들어보기 '''
denoised_data = t2_amp

scaled = numpy.int16(denoised_data/numpy.max(numpy.conj(denoised_data)) * 32768)

wavfile.write(fout, fs, scaled)
Audio(fout, autoplay=True)

